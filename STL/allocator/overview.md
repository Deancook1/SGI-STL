# STL ALLOCATOR
## 1:各种宏的定义及功能
### 编译器兼容性宏

| 宏名称                              | 作用                                                                 | 触发条件                                                                 |
|-------------------------------------|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| `__PRIVATE`                        | 控制访问权限                                                        | SunPRO编译器下定义为`public`，其他编译器为`private`                      |
| `__STL_STATIC_TEMPLATE_MEMBER_BUG` | 标记编译器对模板静态成员的支持缺陷                                   | 旧版编译器（如g++ 2.7.2）无法正确处理模板类的静态成员时定义              |
| `__STL_FUNCTION_TMPL_PARTIAL_ORDER`| 启用函数模板偏特化支持                                              | 支持C++部分模板排序的编译器定义                                          |

### 内存分配控制宏

| 宏名称                  | 作用                                                                 | 关联代码                                                                 |
|-------------------------|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| `__USE_MALLOC`          | 强制使用一级分配器（`malloc_alloc`）                                | 当`__STL_STATIC_TEMPLATE_MEMBER_BUG`定义时自动启用                       |
| `__THROW_BAD_ALLOC`     | 定义内存不足时的行为                                                | 根据`__STL_NO_BAD_ALLOC`决定抛出异常或终止程序                           |


### 多线程支持宏

| 宏名称                          | 作用                                                                 | 实现细节                                                                 |
|---------------------------------|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| `__STL_THREADS`                | 启用多线程支持                                                      | 定义后引入锁机制                                                         |
| `__NODE_ALLOCATOR_THREADS`     | 标记当前是否线程安全                                                | 根据`__STL_THREADS`自动设置                                             |
| `__NODE_ALLOCATOR_LOCK`        | 分配时的加锁操作                                                    | SGI线程特有实现：`if (threads && __us_rsthread_malloc) _M_acquire_lock()`|
| `__NODE_ALLOCATOR_UNLOCK`      | 释放时的解锁操作                                                    | 与锁配对使用                                                             |

### 调试与校验宏

| 宏名称          | 作用                        | 典型用法                     |
|-----------------|-----------------------------|------------------------------|
| `__STL_DEBUG`  | 启用调试模式                | 配合`debug_alloc`使用        |
| `NDEBUG`       | 禁用断言检查                | 定义后跳过`assert`检查       |

### 标准兼容性宏

| 宏名称                          | 作用                             | 标准对应                     |
|---------------------------------|----------------------------------|------------------------------|
| `__STL_USE_STD_ALLOCATORS`     | 启用标准兼容的allocator接口      | 控制`allocator`类的编译      |
| `__STL_NO_BAD_ALLOC`           | 禁用`bad_alloc`异常              | 改用`exit(1)`终止程序        |

### 平台特定宏

| 宏名称          | 作用                        | 适用平台               |
|-----------------|-----------------------------|------------------------|
| `__SUNPRO_CC`  | SunPRO编译器特殊处理        | SunPRO编译器环境       |
| `__GNUC__`     | GCC编译器优化开关           | GCC编译器环境          |
| `__RESTRICT`   | 限制指针别名优化            | 类似C99的`restrict`    |


## 2：代码逻辑
### 2.1 ：流程图
![Example Image](https://github.com/Deancook1/SGI-STL/blob/master/STL/allocator/images/deepseek_mermaid_20250611_911423.png)
通过宏定义来控制代码的生成逻辑

### 2.2 : SGI STL 内存分配器类功能解析

#### 底层分配器实现类
| 类名                      | 核心功能                                                                 | 关键特性                                                                 |
|---------------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|
| `__malloc_alloc_template` | 一级分配器，直接调用 `malloc/free`                                      | - 处理内存不足回调<br>- 无内存池<br>- 线程安全依赖全局锁                 |
| `__default_alloc_template`| 二级分配器，基于内存池的自由链表管理                                    | - 16级自由链表（8-128B）<br>- 联合体优化存储<br>- 多线程细粒度锁         |

以上两种类实现的是对内存的底层分配，参数是要分配的内存大小，返回 void* 类型的相应内存的指针

#### 接口适配器类
| 类名           | 功能定位                     | 核心能力                                                                 |
|----------------|------------------------------|--------------------------------------------------------------------------|
| `simple_alloc` | 统一分配器接口的轻量封装      | - 仅包装 `allocate/deallocate`<br>- 无类型安全检测 |

上述类是对__malloc_alloc_template 与 __default_alloc_template 的封装
1：使得内存分配具备了标准接口，无需关心具体调用的方式
2：底层分配器操作 void *，而 simple_alloc 类型安全得以增强
3：零开销成本，所有方法均为static ，无对象实例化开销，模版在编译期实例化，无运行时多态开销

| 类名               | 功能定位                     | 核心能力                                                                 |
|--------------------|----------------------------|--------------------------------------------------------------------------|
| `allocator`        | 标准兼容的内存分配器         | - 符合 `std::allocator` 接口规范<br>- 提供 `allocate/deallocate`<br>- 支持 `rebind` 机制 |
| `__allocator`      | 内部泛型分配器适配器         | - 适配任意底层分配器（如 `malloc`）<br>- 保留分配器状态（如内存池）<br>- **内部实现**（非标准接口） |

上述类是适配器模式，能够封装 simple_alloc 
1：在simple_alloc 的基础上增加construct() 对象构造 和 destroy() 显示析构
2：提供了rebind 机制，允许从 allocator<T> 获取 allocator<Node<T>>
3:这两种分配器的区别主要是 allocator 是无状态的，内存分配依赖 STL 标准库中提供的 static 方法，__allocator 内存持有底层分配器的指针，是有状态的，可以定制化内存操作


#### 调试与工具类
| 类名            | 用途                         | 实现原理                                                                 |
|-----------------|------------------------------|--------------------------------------------------------------------------|
| `debug_alloc`   | 带边界检查的调试分配器        | - 分配时存储大小头（`_S_extra`）<br>- 释放时校验大小匹配                  |
| `_Alloc_traits` | 分配器特性萃取模板            | - 通过 `_S_instanceless` 判断状态<br>- 自动选择最优策略                   |

引入了模版编程以后，类型也成为了一个重要的参数，因此设计出各种各种的 traits ，提取类型，在_Alloc_traits 中有一个重要成员_S_instanceless，在
容器之间拷贝，赋值，swap时的分配器传播：is_stateless=true的时候可以跳过分配器比较和拷贝，减少分支判断和内存操作，同时在代码生成的时候，无状态分配器的优化代码

### 无状态 vs 有状态分配器关键差异

| 场景               | 无状态分配器 (`_S_instanceless=true`)          | 有状态分配器 (`_S_instanceless=false`)         |
|--------------------|-----------------------------------------------|-----------------------------------------------|
| **容器赋值**       | 直接调用 `allocate/deallocate`，无额外检查     | 需要 `operator==` 比较 + 可能的深拷贝          |
| **swap操作**       | 3条`MOV`指令完成交换                          | 需比较分配器 + 可能触发元素级拷贝              |
| **内存释放**       | 任意实例可释放（编译为简单 `free` 调用）       | 必须匹配实例（可能需查表释放特定内存池）        |
| **生成的指令数**   | ~10条（简单内存操作）                         | ~50+条（含比较/分支/拷贝）                     |

#### 辅助类
| 类名     | 角色               | 典型实现                                                                 |
|----------|--------------------|--------------------------------------------------------------------------|
| `_Lock`  | RAII 锁封装        | ```cpp<br>class _Lock {<br>  _Lock() { __NODE_ALLOCATOR_LOCK; }<br>  ~_Lock() { __NODE_ALLOCATOR_UNLOCK; }<br>};<br>``` |




